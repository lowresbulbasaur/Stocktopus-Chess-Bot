# -*- coding: utf-8 -*-
"""Stocktopus_Source_Code.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZqF-Dk-FqZE7SlAoPI_OJ2yg5GufMJZV
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import tensorflow as tf
from google.colab import drive
drive.mount('/content/drive')
path = "/content/drive/My Drive/Stocktopi Secret Sauce/chessDataProcessed.csv"

"""Main Python Chess Stuff"""

!pip install python-chess==0.31.3
!chmod 755 -R '/content/drive/My Drive/Stocktopi Secret Sauce/stockfish/stockfish_14.1_linux_x64_bmi2'

import chess
import chess.engine

# this function turns a FEN string into a board
def get_board(fen):
  return chess.Board(fen)

# this function returns the stockfish eval of the board
# code modified from https://colab.research.google.com/drive/1GSeBQdyZH_nHvl52XW0uhXV3Cslho24O#scrollTo=QauvWk2MkddY
def stockfish(board, depth):
  stockfish_path = r'/content/drive/My Drive/Stocktopi Secret Sauce/stockfish/stockfish_14.1_linux_x64_bmi2'
  with chess.engine.SimpleEngine.popen_uci(stockfish_path) as sf:
    result = sf.analyse(board, chess.engine.Limit(depth=depth))
    score = result['score'].white().score()
    return score

test = get_board('rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1')
print(test)
print(stockfish(test, 0))

"""Setting up Stocktopus"""

model = tf.keras.models.load_model("/content/drive/My Drive/Stocktopi Secret Sauce/stocktopus_model3.h5")

import chess.polyglot

#transposition table can improve performance in some positions, but it also leads to some errors with upper/lower bounding on nodes which
#have been cut by alpha-beta pruning

ttable = {}
def hasTranspose(board):
  key = chess.polyglot.zobrist_hash(board)
  return not ttable.get(key)==None

def getTranspose(board):
  key = chess.polyglot.zobrist_hash(board)
  return ttable[key]

def addTranspose(board, eval, depth, move):
  key = chess.polyglot.zobrist_hash(board)
  ttable[key] = (eval, depth, move.uci())

def clearTranspose():
  ttable.clear()

#hasTranspose(board)

#opening book
otable = {}
def getMove(board):
  return otable.get(chess.polyglot.zobrist_hash(board))

def addMove(fen, uci):
  otable[chess.polyglot.zobrist_hash(chess.Board(fen = fen))] = chess.Move.from_uci(uci)

#reads the opening book from file
#current opening: Queen's Gambit repertoire
def read_book():
  with open("/content/drive/My Drive/Stocktopi Secret Sauce/openings/queens_gambit.txt") as f:
    lines = f.readlines()
    for line in lines:
      spl = line.rstrip().split(',')
      #ignore comments
      if(spl[0]==''):
        continue
      addMove(spl[0], spl[1])

read_book()
#otable

from tensorflow.python.framework.convert_to_constants import convert_variables_to_constants_v2
# Convert Keras model to ConcreteFunction
full_model = tf.function(lambda x: model(x))
full_model = full_model.get_concrete_function(
    tf.TensorSpec(model.inputs[0].shape, model.inputs[0].dtype))

# used for the minimax algorithm
def square_to_index(square):
  squares_index = {
    'a': 0,
    'b': 1,
    'c': 2,
    'd': 3,
    'e': 4,
    'f': 5,
    'g': 6,
    'h': 7
  }
  letter = chess.square_name(square)
  return 8 - int(letter[1]), squares_index[letter[0]]

#turns board into a 512 element input array
def split_dims(board):
  ans = np.zeros((512,), dtype=np.int8)

  # add pieces
  for piece in chess.PIECE_TYPES:
    for square in board.pieces(piece, chess.WHITE):
      idx = np.unravel_index(square, (8, 8))
      index1 = piece-1
      index2 = 7-idx[0]
      index3 = idx[1]
      ans[64*index1+8*index2+index3] = 1
    for square in board.pieces(piece, chess.BLACK):
      idx = np.unravel_index(square, (8, 8))
      index1 = piece-1
      index2 = 7-idx[0]
      index3 = idx[1]
      ans[64*index1+8*index2+index3] = -1

  aux = board.turn
  board.turn = chess.WHITE
  for move in board.legal_moves:
       i, j = square_to_index(move.to_square)
       ans[6*64+8*i+j] = 1
  board.turn = chess.BLACK
  for move in board.legal_moves:
       i, j = square_to_index(move.to_square)
       ans[7*64+8*i+j] = 1
  board.turn = aux

  return ans

# evaluation function using the predictions of the neural net
def minimax_eval(board):
  board_input = split_dims(board)
  board_input = np.expand_dims(board_input, 0)
  eval = full_model(board_input.astype(np.float32))[0][0]
  return eval


def piece_count(board):
  eval = 0
  value_map = {
      1 : 1.16,
      2 : 3.52,
      3 : 3.91,
      4 : 5.36,
      5 : 11.29,
      6 : 100
  }
  for piece in chess.PIECE_TYPES:
    eval += value_map[piece]*len(board.pieces(piece, chess.WHITE))
    eval -= value_map[piece]*len(board.pieces(piece, chess.BLACK))
  return eval


def minimax(board, depth, alpha, beta, maximizing_player, uses_ttable = False):
  # gets move from transposition table
  if hasTranspose(board) and uses_ttable:
    t_eval, t_depth, t_move = getTranspose(board)
    if depth<=t_depth:
      return t_eval

  #checkmate evaluation
  if board.is_checkmate():
    if board.turn == chess.BLACK:
      return 1000
    else:
      return -1000

  #draw
  if board.is_game_over():
    return 0

  #leaf node in search tree
  if depth == 0:
    eval = minimax_eval(board)
    return eval

  if maximizing_player:
    max_eval = -np.inf

    #null move pruning
    if not board.is_check():
      board.push(chess.Move.null())
      eval = minimax(board, max(0, depth-3), alpha, beta, False, uses_ttable)
      board.pop()
      max_eval = max(max_eval, eval)
      alpha = max(alpha, eval)
      if beta <= alpha:
        if uses_ttable:
          addTranspose(board, max_eval, depth, chess.Move.null())
        return max_eval

    #main recursion
    best_move = chess.Move.null()
    for move in sort_moves(board, board.legal_moves, uses_ttable):
      tactical = False
      if board.gives_check(move):
        tactical = True
      elif board.is_capture(move):
        if board.is_en_passant(move):
          tactical = False
        elif board.piece_at(move.to_square).piece_type!=chess.PAWN:
          tactical = True

      #uses tactic eval when the final move is a capture/check
      if tactical and depth==1:
        board.push(move)
        eval = tactic_eval(board, 3, alpha, beta, False)
      else:
        board.push(move)
        eval = minimax(board, depth - 1, alpha, beta, False, uses_ttable)
      board.pop()

      if eval>max_eval:
        max_eval = eval
        best_move = move

      #alpha-beta pruning
      alpha = max(alpha, eval)
      if beta <= alpha:
        if uses_ttable:
          addTranspose(board, max_eval, depth, chess.Move.null())
        break
    if uses_ttable:
      addTranspose(board, max_eval, depth, best_move)
    return max_eval
  else:
    min_eval = np.inf

    #null move pruning
    if not board.is_check():
      board.push(chess.Move.null())
      eval = minimax(board, max(0, depth-3), alpha, beta, True, uses_ttable)
      board.pop()
      min_eval = min(min_eval, eval)
      beta = min(beta, eval)
      if beta <= alpha:
        if uses_ttable:
          addTranspose(board, min_eval, depth, chess.Move.null())
        return min_eval

    #main recursion
    best_move = chess.Move.null()
    for move in sort_moves(board, board.legal_moves, uses_ttable):
      tactical = False
      if board.gives_check(move):
        tactical = True
      elif board.is_capture(move):
        if board.is_en_passant(move):
          tactical = False
        elif board.piece_at(move.to_square).piece_type!=chess.PAWN:
          tactical = True

      #uses tactic eval when the final move is a capture/check
      if tactical and depth==1:
        board.push(move)
        eval = tactic_eval(board, 3, alpha, beta, True)
      else:
        board.push(move)
        eval = minimax(board, depth - 1, alpha, beta, True, uses_ttable)
      board.pop()

      if eval<min_eval:
        min_eval = eval
        best_move = move

      #alpha-beta pruning
      beta = min(beta, eval)
      if beta <= alpha:
        if uses_ttable:
          addTranspose(board, min_eval, depth, chess.Move.null())
        break
    if uses_ttable:
      addTranspose(board, min_eval, depth, best_move)
    return min_eval


# function to call when making a move
def get_ai_move(board, depth, color = chess.WHITE, uses_ttable = False):
  if getMove(board)!=None:
    return (getMove(board), 0.0)
  max_move = None
  min_move = None
  max_eval = -np.inf
  min_eval = np.inf

  if uses_ttable and len(ttable)>1000000:
    clearTranspose()

  if color==chess.WHITE:
    for move in sort_moves(board, board.legal_moves, uses_ttable):
      board.push(move)
      if board.can_claim_draw():
        eval = 0
        if max_move==None or eval > max_eval:
          max_eval = eval
          max_move = move
      else:
        eval = minimax(board, depth - 1, -np.inf, np.inf, False, uses_ttable)
      board.pop()
      if eval > max_eval:
        max_eval = eval
        max_move = move
    return (max_move, max_eval)
  else:
    for move in sort_moves(board, board.legal_moves, uses_ttable):
      board.push(move)
      if board.can_claim_draw():
        eval = 0
        if min_move==None or eval < min_eval:
          min_eval = eval
          min_move = move
      else:
        eval = minimax(board, depth - 1, -np.inf, np.inf, True, uses_ttable)
      board.pop()
      if eval < min_eval:
        min_eval = eval
        min_move = move
    return (min_move, min_eval)

#prioritizes moves as follows: first the best move from the transposition table at lower depth
#then captures, then checks, then other moves
def movePriority(board, move, uses_ttable = False):
  if hasTranspose(board) and uses_ttable:
    eval, depth, bestMove = getTranspose(board)
    if move.uci() == bestMove:
      return -1
  if board.is_capture(move):
    return 0
  if board.gives_check(move):
    return 1
  return 2

#sorts by captures, then checks
#when moves are sorted prior to alpha-beta pruning, thinking time seems to be reduced by over 50%
def sort_moves(board, movelist, uses_ttable = False):
  return sorted(movelist, key = lambda m : movePriority(board, m, uses_ttable))

def tactic_eval(board, depth, alpha, beta, maximizing_player):
  #checkmate evaluation
  if board.is_checkmate():
    if board.turn == chess.BLACK:
      return 1000
    else:
      return -1000

  #draw
  if board.is_game_over():
    return 0

  if depth == 0:
    eval = piece_count(board)
    return eval

  if maximizing_player:
    max_eval = -np.inf

    if board.is_check():
      #main recursion
      for move in board.legal_moves:
        board.push(move)
        eval = tactic_eval(board, depth - 1, alpha, beta, False)
        board.pop()
        if eval>max_eval:
          max_eval = eval
          alpha = max(alpha, eval)
        if beta <= alpha:
          break
    else:
      #expects null/quiet move
      max_eval = piece_count(board)
      alpha = max(alpha, max_eval)

      #main recursion
      for move in board.legal_moves:
        if board.is_capture(move) or board.gives_check(move):
          board.push(move)
          eval = tactic_eval(board, depth - 1, alpha, beta, False)
          board.pop()
          if eval>max_eval:
            max_eval = eval
            alpha = max(alpha, eval)
          if beta <= alpha:
            break

    return max_eval

  else:
    min_eval = np.inf

    if board.is_check():
      #main recursion
      for move in board.legal_moves:
        board.push(move)
        eval = tactic_eval(board, depth-1, alpha, beta, True)
        board.pop()
        if eval<min_eval:
          min_eval = eval
          beta = min(beta, eval)
        if beta <= alpha:
          break
    else:
      #expects null/quiet move
      min_eval = piece_count(board)
      beta = min(beta, min_eval)

      #main recursion
      for move in board.legal_moves:
        if board.is_capture(move) or board.gives_check(move):
          board.push(move)
          eval = tactic_eval(board, depth - 1, alpha, beta, True)
          board.pop()
          if eval<min_eval:
            min_eval = eval
            beta = min(beta, eval)
          if beta <= alpha:
            break

    return min_eval

"""Stocktopus interaction:"""

import chess.svg
import IPython

#returns a tuple (move, eval)
def stocktopus(board, color, depth = 4, uses_ttable = True):
  return get_ai_move(board, depth, color, uses_ttable)

#displays an arrow with stocktopus' recommended move
def display_stocktopus(board, color, depth = 4, uses_ttable = True, size = 400):
  move, eval = stocktopus(board, color, depth, uses_ttable)
  arrow = chess.svg.Arrow(tail = move.from_square, head = move.to_square)
  html_code = chess.svg.board(board, arrows = [arrow], size = size)
  print("Evaluation: "+str(eval))
  display(IPython.display.HTML(html_code))

def start_game(color, depth = 4, uses_ttable = True, size = 400):
  board = chess.Board()
  # html_code = chess.svg.board(board, size = size)
  # display(IPython.display.HTML(html_code))
  if color==chess.WHITE:
    while True:
      print('Play a move or write \'stop\' to stop\n')
      stop = False
      while True:
        move = input()
        move = move.strip()
        if move=='stop':
          stop = True
          break
        try:
          move = board.parse_san(move)
          board.push(move)
          break
        except ValueError:
          print('That wasn\'t recognized as a valid move. Please try again.\n')
      if stop:
        break
      html_code = chess.svg.board(board, size = size, lastmove=board.peek())
      display(IPython.display.HTML(html_code))
      if board.is_game_over():
        break

      move, eval = stocktopus(board, chess.BLACK, depth, uses_ttable)
      board.push(move)
      html_code = chess.svg.board(board, size = size, lastmove=board.peek())
      display(IPython.display.HTML(html_code))
      if board.is_game_over():
        break
  else:
    while True:
      move, eval = stocktopus(board, chess.WHITE, depth, uses_ttable)
      board.push(move)
      html_code = chess.svg.board(board, size = size, lastmove=board.peek())
      display(IPython.display.HTML(html_code))
      if board.is_game_over():
        break

      print('Play a move or write \'stop\' to stop\n')
      stop = False
      while True:
        move = input()
        move = move.strip()
        if move=='stop':
          stop = True
          break
        try:
          move = board.parse_san(move)
          board.push(move)
          break
        except ValueError:
          print('That wasn\'t recognized as a valid move. Please try again.\n')
      if stop:
        break
      html_code = chess.svg.board(board, size = size, lastmove=board.peek())
      display(IPython.display.HTML(html_code))
      if board.is_game_over():
        break

"""Lichess API"""

#!pip install requests
import requests
import json

#lichess.org api
api_key = 'lip_pEBnKKpwfFVoaKS9vwuh'#do not lose!!!!
headers = {
    'user-agent': 'stocktopus_dev',
    'Authorization': 'Bearer '+api_key
}

payload = {
    'format': 'json'
}

tt_lines = []
def load_trashtalk():
  with open("/content/drive/My Drive/Stocktopi Secret Sauce/trashtalk.txt") as f:
    lines = f.readlines()
    for line in lines:
      tt_lines.append(line.rstrip())
load_trashtalk()
tt_lines

import random

def get_trashtalk():
  return random.choice(tt_lines)

def get_decoded_board(move_str):
    board = chess.Board()
    if len(move_str)==0:
      return (board, True)
    spl = move_str.split(' ')
    for i in spl:
      board.push(chess.Move.from_uci(i))
    return (board, len(spl)%2==0)

def chat(game_id, text):
  requests.post('https://lichess.org/api/bot/game/'+game_id+'/chat', headers=headers, data={'room':'player', 'text':text})

#finds and challenges one person in real time
def find_challenge():
  events = requests.get("https://lichess.org/api/stream/event", headers = headers, params = payload, stream = True)
  in_game = False#only plays one game at a time
  game_id = None
  id = -1
  game_stream = None
  game_color = None
  search_depth = 3
  trashtalk = False
  use_lichess_database = False
  for line in events.iter_lines():
      # filter out keep-alive new lines
      if line:
          decoded_line = line.decode('utf-8')
          decoded_line = json.loads(decoded_line)
          #print(decoded_line)

          #reads and accepts challenges
          if decoded_line['type']=='challenge' and decoded_line['challenge']['speed']=='correspondence' and (not in_game):
            id = decoded_line['challenge']['id']
            requests.post('https://lichess.org/api/challenge/'+id+'/accept', headers = headers)
            in_game = True

          #waits for the game start of the challenge
          if decoded_line['type']=='gameStart':
            game_id = decoded_line['game']['gameId']
            if game_id!=id:
              continue
            game_color = decoded_line['game']['color']
            chat(game_id, 'prepare to get stocktopus\'d >:)')
            game_stream = requests.get('https://lichess.org/api/bot/game/stream/'+game_id, headers=headers, params = payload, stream = True)
            break

  game_color = game_color=='white'

  #plays game
  for line in game_stream.iter_lines():
    #filter out keep-alive new lines
    if line:
      decoded_line = line.decode('utf-8')
      decoded_line = json.loads(decoded_line)

      if decoded_line['type']=='gameFull':
        game_state = decoded_line['state']
      elif decoded_line['type']=='gameState':
        game_state = decoded_line
      elif decoded_line['type']=='chatLine':
        txt = decoded_line['text']
        txt = txt.strip().lower()
        if txt=='configure highdepth':
          search_depth = 4
          chat(game_id, 'depth set to 4')
        if txt=='configure lowdepth':
          search_depth = 2
          chat(game_id, 'depth set to 2')
        if txt=='configure middepth':
          search_depth = 3
          chat(game_id, 'depth set to 3')
        if txt=='configure trashtalk':
          trashtalk = True
          chat(game_id, get_trashtalk())
        if txt=='configure clean':
          trashtalk = False
          chat(game_id, '...')
        if txt=='configure use database':
          use_lichess_database = True
          chat(game_id, 'using lichess database')
        if txt=='configure stop database':
          use_lichess_database = False
          chat(game_id, 'stopped using lichess database')
        continue
      else:
        continue

      board, to_move = get_decoded_board(game_state['moves'])

      if to_move==game_color:
        move = None
        if use_lichess_database:
          op_move = lichess_opening(board)
          ed_move = lichess_endgame(board)
          if op_move!=None:
            move = op_move
          elif ed_move!=None:
            move = ed_move
        if move==None:
          move, eval = stocktopus(board, game_color, search_depth)
        if move==None:
          #game ended/no legal moves
          break
        move = move.uci()
        requests.post('https://lichess.org/api/bot/game/'+game_id+'/move/'+str(move), headers=headers)
        if(trashtalk):
          txt = get_trashtalk()
          chat(game_id, txt)

#accepts incoming challenges and plays a move in ongoing games
def update_games():
  #accept challenges
  challenges = requests.get('https://lichess.org/api/challenge', headers=headers, params=payload).json()
  for i in challenges['in']:
    challenge_id = i['id']
    if i['speed']=='correspondence':
      requests.post('https://lichess.org/api/challenge/'+challenge_id+'/accept', headers = headers)

  #get ongoing games, process chat, and play move
  #will only process requests if it is stocktopus' turn to move
  ongoing_games = requests.get('https://lichess.org/api/account/playing', headers=headers, params=payload).json()
  ongoing_games = ongoing_games['nowPlaying']
  for i in ongoing_games:
    if i['isMyTurn']:
      search_depth = 3
      color = i['color']=='white'
      game_id = i['gameId']
      game_chat = requests.get('https://lichess.org/api/bot/game/'+game_id+'/chat', headers=headers).json()
      trashtalk = False
      use_lichess_database = False

      #just loop through chat chronologically lol
      for j in range(len(game_chat)):
        txt = game_chat[j]['text'].strip().lower()
        if txt=='configure highdepth':
          search_depth = 4
          if j==len(game_chat)-1:
            chat(game_id, 'depth set to 4')
        if txt=='configure lowdepth':
          search_depth = 2
          if j==len(game_chat)-1:
            chat(game_id, 'depth set to 2')
        if txt=='configure middepth':
          search_depth = 3
          if j==len(game_chat)-1:
            chat(game_id, 'depth set to 3')
        if txt=='configure trashtalk':
          trashtalk = True
          if j==len(game_chat)-1:
            chat(game_id, get_trashtalk())
        if txt=='configure clean':
          trashtalk = False
          if j==len(game_chat)-1:
            chat(game_id, '...')
        if txt=='configure use database':
          use_lichess_database = True
          if j==len(game_chat)-1:
            chat(game_id, 'using lichess database')
        if txt=='configure stop database':
          use_lichess_database = False
          if j==len(game_chat)-1:
            chat(game_id, 'stopped using lichess database')
      board = chess.Board(fen=i['fen'])
      move = None
      if use_lichess_database:
        op_move = lichess_opening(board)
        ed_move = lichess_endgame(board)
        if op_move!=None:
          move = op_move
        elif ed_move!=None:
          move = ed_move
      if move==None:
        move, eval = stocktopus(board, color, search_depth)
      if move==None:
          #game ended/no legal moves
          break
      move = move.uci()
      requests.post('https://lichess.org/api/bot/game/'+game_id+'/move/'+str(move), headers=headers)
      if(trashtalk):
        txt = get_trashtalk()
        chat(game_id, txt)

#returns most commonly played move from lichess database
def lichess_opening(board):
  fen = board.fen()
  response = requests.get('https://explorer.lichess.ovh/lichess',params = {'fen':fen}).json()
  if len(response['moves'])==0:
    return None
  uci = response['moves'][0]['uci']
  return chess.Move.from_uci(uci)

def lichess_endgame(board):
  fen = board.fen()
  response = requests.get('https://tablebase.lichess.ovh/standard', params = {'fen':fen}).json()
  if response['category']=='unknown' or len(response['moves'])==0:
    return None
  uci = response['moves'][0]['uci']
  return chess.Move.from_uci(uci)

"""Testing and Running Stocktopus:"""

find_challenge()

update_games()

start_game(chess.BLACK, depth = 3)

board = chess.Board(fen = 'rnbqkb1r/pppppppp/5n2/8/3P4/8/PPP1PPPP/RNBQKBNR w KQkq - 1 2')
lichess_opening(board)

len(ttable)

# Commented out IPython magic to ensure Python compatibility.
#IGNORE: for testing performance
# %timeit minimax_eval(board)

"""Stocktopus Neural Net Training:"""

def eval(fen):
  return stockfish(get_board(fen), 0)

eval('rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1')

data = np.load("/content/drive/My Drive/Stocktopi Secret Sauce/dataset/dataset_processed.npy")
#original dataset from https://www.youtube.com/watch?v=ffzvhe97J4Q
#14 by 8 by 8 input, where 12 of the 8 by 8s encode piece placements for either color and the other 2 encode legal moves
#^ no longer true, input shape is 513,
#every input is either 1 or 0
#evaluations in centipawns

data = data[:1000000]

data = data[abs(data[:,-1])<30,:]

where_endgame = np.all(data[:, 256:320]==0, axis=1)
data = data[where_endgame, :]

data.shape

#TODO: shuffle and assign to train/test
trainx = data[:350000, 0:512]
trainy = data[:350000, -1:]
testx = data[350000:, 0:512]
testy = data[350000:, -1:]

model = tf.keras.models.Sequential([
    #tf.keras.layers.Flatten(input_shape = (8, 8, 8)),
    tf.keras.layers.Dense(256, activation = 'relu'),
    tf.keras.layers.Dense(32, activation = 'relu'),
    tf.keras.layers.Dense(1, activation = 'linear')
])

loss_fn = tf.keras.losses.MeanSquaredError()
model.compile(optimizer = tf.keras.optimizers.Adam(learning_rate = 0.003), loss = loss_fn)

model.fit(trainx, trainy, epochs = 5, batch_size = 1000)

model.evaluate(testx, testy)

model.predict(testx[:10])

testx.shape

testy[:10]

"""Older Neural Net Training Stuff"""

#linear model
weights = model.trainable_variables[0]
weights = weights.numpy().reshape((512,))
pawn_val = weights[9:56].mean()
knight_val = weights[64:128].mean()
bishop_val = weights[128:192].mean()
rook_val = weights[192:256].mean()
queen_val = weights[256:320].mean()
print(pawn_val, knight_val, bishop_val, rook_val, queen_val)

model.save("/content/drive/My Drive/Stocktopi Secret Sauce/stocktopus_model_endgame1.h5")

"""OLD STUFF (can ignore):"""

df = pd.read_csv(path)

df = df.drop(columns = ['Unnamed: 0'])

df['hasMate'] = df['Evaluation'].apply(lambda x: x[0]=='#')

df

df_new = df[~df['hasMate']]
df_new['Evaluation'] = df_new['Evaluation'].astype('int32')/100.0
#df_new = df_new[(df_new['Evaluation']>-1000)&(df_new['Evaluation']<1000)]

df_new

"""Daddy Stocktopus' DNA"""

train_x = df_new.loc[1:800000, '0':'68'].to_numpy()
test_x = df_new.loc[800001:, '0':'68'].to_numpy()
train_y = df_new.loc[1:800000, 'Evaluation'].to_numpy()
test_y = df_new.loc[800001:, 'Evaluation'].to_numpy()

model = tf.keras.models.Sequential([
    tf.keras.layers.Dense(256, activation = 'relu'),
    tf.keras.layers.Dense(32, activation = 'relu'),
    tf.keras.layers.Dense(1, activation = 'linear')
])

loss_fn = tf.keras.losses.MeanSquaredError()
model.compile(optimizer = tf.keras.optimizers.Adam(learning_rate = 2e-4), loss = loss_fn)

model.fit(train_x, train_y, epochs = 10, batch_size = 1000)

#first 64:
#empty space is 0
#1 pawn
#2 knight
#3 bishop
#4 rook
#5 queen
#6 king
#negative numbers for black pieces

#Next: -1 for black to move, 1 for white to move

#Next two: 2 for kingside, 1 for queenside, 3 for both

#Then adds the half-move counter/50, and the full-move counter/50

#en passant is ignored
def fenConvert(s):
    ints = set(['1', '2', '3', '4', '5', '6', '7', '8'])
    pieceMap = {'p' : -1, 'n' : -2, 'b' : -3, 'r' : -4, 'q' : -5, 'k' : -6,
               'P' : 1, 'N' : 2, 'B' : 3, 'R' : 4, 'Q' : 5, 'K' : 6}
    ans = []
    spl = s.split()
    for i in spl[0]:
        if i in ints:
            for j in range(int(i)):
                ans.append(0)
            continue
        if i=='/':
            continue
        ans.append(pieceMap[i])
    if spl[1]=='w':
        ans.append(1)
    else:
        ans.append(-1)

    castlingMap = {'KQkq' : [3, -3], 'KQk' : [3, -2], 'KQq' : [3, -1], 'KQ' : [3, 0],
                  'Kkq' : [2, -3], 'Kk' : [2, -2], 'Kq' : [2, -1], 'K' : [2, 0],
                  'Qkq' : [1, -3], 'Qk' : [1, -2], 'Qq' : [1, -1], 'Q' : [1, 0],
                  'kq' : [0, -3], 'k' : [0, -2], 'q' : [0, -1], '-' : [0, 0]}
    castle = castlingMap[spl[2]]
    ans.append(castle[0])
    ans.append(castle[1])
    ans.append(float(spl[4])/50.0)
    ans.append(float(spl[5])/50.0)
    return ans

#fenConvert('rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1')

#Neural Net Neural Net
#Variables to check:
#Optimizer, Epochs, Each Layer Size, Learning Rate, Batch Size
#Only optimizer is a categorical variable, rest are gradient so thats cool, im not gonna do optimizer for now


def test_meta(epoch_num=10, layer1_size=256, layer2_size=32, learn_rate=.03, batch_num=1000):


  meta_model = tf.keras.models.Sequential([
      tf.keras.layers.Dense(layer1_size, activation = 'relu'),
      tf.keras.layers.Dense(layer2_size, activation = 'relu'),
      tf.keras.layers.Dense(1, activation = 'linear')
  ])

  loss_fn = tf.keras.losses.MeanSquaredError()
  meta_model.compile(optimizer = tf.keras.optimizers.Adam(learning_rate = learn_rate), loss = loss_fn)

  meta_model.fit(train_x, train_y, epochs = epoch_num, batch_size = batch_num)

  return meta_model.evaluate(test_x, test_y)

"""Ignore (old data processing stuff):"""

new_x = big_x[:, :6]-big_x[:, 6:12]
new_x = np.concatenate([new_x, big_x[:, 12:]], axis=1)
new_x = new_x.reshape((1500000, 512))

new_y = big_y/100.0

new_data = np.concatenate([new_x, new_y.reshape(1500000, 1)], axis=1)
#new_data = np.random.shuffle(new_data)
new_data

np.random.shuffle(new_data)
new_data

